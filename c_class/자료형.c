#include <stdio.h>
int main(void)
{
	//문자 / 정수 /실수
	//문자 :char/1바이트 / -128 ~ 127
	//정수:short /2바이트 / -32000 ~ 32000
	//정수:int / 4바이트 / -21억 ~ 21억
	//정수:long / 4바이트 / -21억 ~ 21억
	//정수:long long /8바이트/ 
	//실수: float /4바이트 
	//실수: double / 8바이트
	//실수: long double / 8바이트 이상
	//1바이트=8비트
	//1비트당 2의 1제곱
	//비트 데이터를 저장하거나 표현할 수 있는 가장 작은 단위이며 1비트는 0또는 1중의 하나의 값만 저장 가능
	//1바이트 (-128~ 127 / 0~ 225)
	//값의 범위 signed 기본값 맨 왼쪽 최상위 비트를 부호비트로 사용 0 양수로 판단 1 음수로 판단/unsigned
	//sizeof 연산자 값을 직접 넣어도 되고 자료형을 넣어서도 몇바이트인지 확인 가능
	//영어와 일부 특수문자는 숫자와 매핑되어있다
	//상수(리터럴 심볼릭 매크로):심볼릭 주로 사용
	//자료형과 초기화될 데이터의 자료형이 다르다면 변수자료형에 맞춰서 자동 형변환이 일어난다
	//%d-정수 %c-문자 %f- 실수
	unsigned int max_number = 2200000000;
	printf("%u\n", max_number);

	//signed: 맨 왼쪽 비트는 부호비트로 적용됨
	//unsigned:모든 비트는 숫자를 표현할때 사용 양수부호만 사용가능
	// unsigned 값의 범위 :0부터 2의 n승 -1
	//부호비트는 0을 양수로 읽고 1은 음수로 읽음 양수범위는 0부터 127까지 128가지의 가짓수를 가질수 있음  음수범위는 -1부터 -128까지 사용할 수 있음
	//자료형의 자동형변환
	double change_number = 10;
	printf("%.15f\n", change_number);
	
	//자동형변환2 (소수부의 손실 (소수점이 사라지는 현상))
	int change_number2 = 5.1123;
	printf("%d\n", change_number2);

	//명시적 형변환
	printf("%d\n", (int)1.1234); 
	printf("%d\n", (short)1.1234);///메모리 절약이 필요할때 short 사용
	printf("%f\n", (double)22);//메모리 많이 참 소수점 많음 정밀한 작업할때 사용 좋음
	printf("%f\n", (float)22);//속도가 굉장히 중요한 작업일때 사용 메모리 절약 가능
	return 0;
}